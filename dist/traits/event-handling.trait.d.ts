import { types } from '../types';
import { Event } from '../components/event';
export declare const EventHandlingTrait: import("@traits-ts/core").Trait<(base: {
    new (): {
        [x: string]: any;
        initialize(): void;
        registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
        getHandler(messageType: types.MessageType<types.Message>): types.Handler[] | undefined;
        getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler[];
        getTypeByHandler(handlerReference: types.Handler): any;
        handle(message: types.Message, execution?: types.Execution): Promise<void>;
        handleSequential(message: types.Message): Promise<void>;
        handleConcurrent(message: types.Message): Promise<any>;
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler[]>;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
}) => {
    new (): {
        [x: string]: any;
        eventBus: types.EventBus;
        initialize(): void;
        setupEventHandlers(): void;
        registerEventHandler(eventType: types.MessageType<types.Event>, handler: types.Handler, shouldOverride?: boolean): void;
        subscribeTo(eventType: types.MessageType<types.Event>, handler: types.Handler, shouldOverride?: boolean): void;
        getSubscribedEvents(): types.MessageType<types.Event>[];
        on(event: types.Event): Promise<void>;
        publish(event: types.Event): Promise<void>;
        registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
        getHandler(messageType: types.MessageType<types.Message>): types.Handler[] | undefined;
        getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler[];
        getTypeByHandler(handlerReference: types.Handler): any;
        handle(message: types.Message, execution?: types.Execution): Promise<void>;
        handleSequential(message: types.Message): Promise<void>;
        handleConcurrent(message: types.Message): Promise<any>;
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler[]>;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
}, [import("@traits-ts/core").Trait<(base: {
    new (): {
        [x: string]: any;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        registerHandler(_messageType: types.MessageType<types.Message>, _handler: types.Handler, _shouldOverride?: boolean): void;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
    [x: string]: any;
}) => {
    new (): {
        [x: string]: any;
        initialize(): void;
        registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
        getHandler(messageType: types.MessageType<types.Message>): types.Handler[] | undefined;
        getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler[];
        getTypeByHandler(handlerReference: types.Handler): any;
        handle(message: types.Message, execution?: types.Execution): Promise<void>;
        handleSequential(message: types.Message): Promise<void>;
        handleConcurrent(message: types.Message): Promise<any>;
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler[]>;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
}, [import("@traits-ts/core").Trait<(base: any) => {
    new (): {
        [x: string]: any;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        registerHandler(_messageType: types.MessageType<types.Message>, _handler: types.Handler, _shouldOverride?: boolean): void;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
    [x: string]: any;
}, undefined>]>]>;
