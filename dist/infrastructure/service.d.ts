import { types } from '../types';
declare const Service_base: (new () => {
    [x: string]: any;
    commandBus: types.CommandBus;
    initialize(): void;
    setupCommandHandlers(): void;
    registerCommandHandler(commandType: types.MessageType<types.Command>, handler: types.Handler, shouldOverride?: boolean): void;
    send(command: types.Command): Promise<any>;
    registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
    getHandler(messageType: types.MessageType<types.Message>): types.Handler | undefined;
    getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler;
    getTypeByHandler(handlerReference: types.Handler): any;
    handle(message: types.Message): Promise<any>;
    "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler>;
    setupHandlers(props: {
        handlers: Map<types.MessageType<types.Message>, types.Handler>;
        registrator?: Function | undefined;
        isBoundable?: boolean | undefined;
        handleableTypes?: types.MessageType<types.Message>[] | undefined;
    }): void;
    handles(): Map<types.MessageType<types.Command>, types.Handler>;
    subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
    overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
    hasHandler(messageType: types.MessageType<types.Message>): boolean;
    removeHandler(messageType: types.MessageType<types.Message>): void;
    getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
    setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
    getHandleableTypes(): types.MessageType<types.Message>[];
    ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    getHandledTypes(): types.MessageType<types.Message>[];
    getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
    getHandledMessages(): types.MessageType<types.Message>[];
    getHandledCommands(): types.MessageType<types.Command>[];
    getHandledEvents(): types.MessageType<types.Event>[];
    getHandledTypesNames(): string[];
    "eveble:handleable-types": types.MessageType<types.Message>[];
} & {
    [x: string]: any;
    initialize(): void;
    registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
    getHandler(messageType: types.MessageType<types.Message>): types.Handler | undefined;
    getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler;
    getTypeByHandler(handlerReference: types.Handler): any;
    handle(message: types.Message): Promise<any>;
    "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler>;
    setupHandlers(props: {
        handlers: Map<types.MessageType<types.Message>, types.Handler>;
        registrator?: Function | undefined;
        isBoundable?: boolean | undefined;
        handleableTypes?: types.MessageType<types.Message>[] | undefined;
    }): void;
    handles(): Map<types.MessageType<types.Command>, types.Handler>;
    subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
    overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
    hasHandler(messageType: types.MessageType<types.Message>): boolean;
    removeHandler(messageType: types.MessageType<types.Message>): void;
    getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
    setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
    getHandleableTypes(): types.MessageType<types.Message>[];
    ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    getHandledTypes(): types.MessageType<types.Message>[];
    getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
    getHandledMessages(): types.MessageType<types.Message>[];
    getHandledCommands(): types.MessageType<types.Command>[];
    getHandledEvents(): types.MessageType<types.Event>[];
    getHandledTypesNames(): string[];
    "eveble:handleable-types": types.MessageType<types.Message>[];
} & {
    [x: string]: any;
    setupHandlers(props: {
        handlers: Map<types.MessageType<types.Message>, types.Handler>;
        registrator?: Function | undefined;
        isBoundable?: boolean | undefined;
        handleableTypes?: types.MessageType<types.Message>[] | undefined;
    }): void;
    handles(): Map<types.MessageType<types.Command>, types.Handler>;
    subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
    registerHandler(_messageType: types.MessageType<types.Message>, _handler: types.Handler, _shouldOverride?: boolean): void;
    overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
    hasHandler(messageType: types.MessageType<types.Message>): boolean;
    removeHandler(messageType: types.MessageType<types.Message>): void;
    getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
    setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
    getHandleableTypes(): types.MessageType<types.Message>[];
    ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    getHandledTypes(): types.MessageType<types.Message>[];
    getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
    getHandledMessages(): types.MessageType<types.Message>[];
    getHandledCommands(): types.MessageType<types.Command>[];
    getHandledEvents(): types.MessageType<types.Event>[];
    getHandledTypesNames(): string[];
    "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
    "eveble:handleable-types": types.MessageType<types.Message>[];
} & {
    [x: string]: any;
    eventBus: types.EventBus;
    initialize(): void;
    setupEventHandlers(): void;
    registerEventHandler(eventType: types.MessageType<types.Event>, handler: types.Handler, shouldOverride?: boolean): void;
    subscribeTo(eventType: types.MessageType<types.Event>, handler: types.Handler, shouldOverride?: boolean | undefined): void;
    getSubscribedEvents(): types.MessageType<types.Event>[];
    on(event: types.Event): Promise<void>;
    publish(event: types.Event): Promise<void>;
    registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
    getHandler(messageType: types.MessageType<types.Message>): types.Handler[] | undefined;
    getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler[];
    getTypeByHandler(handlerReference: types.Handler): any;
    handle(message: types.Message, execution?: types.Execution): Promise<void>;
    handleSequential(message: types.Message): Promise<void>;
    handleConcurrent(message: types.Message): Promise<any>;
    "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler[]>;
    setupHandlers(props: {
        handlers: Map<types.MessageType<types.Message>, types.Handler>;
        registrator?: Function | undefined;
        isBoundable?: boolean | undefined;
        handleableTypes?: types.MessageType<types.Message>[] | undefined;
    }): void;
    handles(): Map<types.MessageType<types.Command>, types.Handler>;
    subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
    overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
    hasHandler(messageType: types.MessageType<types.Message>): boolean;
    removeHandler(messageType: types.MessageType<types.Message>): void;
    getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
    setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
    getHandleableTypes(): types.MessageType<types.Message>[];
    ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    getHandledTypes(): types.MessageType<types.Message>[];
    getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
    getHandledMessages(): types.MessageType<types.Message>[];
    getHandledCommands(): types.MessageType<types.Command>[];
    getHandledEvents(): types.MessageType<types.Event>[];
    getHandledTypesNames(): string[];
    "eveble:handleable-types": types.MessageType<types.Message>[];
} & {
    [x: string]: any;
    initialize(): void;
    registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
    getHandler(messageType: types.MessageType<types.Message>): types.Handler[] | undefined;
    getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler[];
    getTypeByHandler(handlerReference: types.Handler): any;
    handle(message: types.Message, execution?: types.Execution): Promise<void>;
    handleSequential(message: types.Message): Promise<void>;
    handleConcurrent(message: types.Message): Promise<any>;
    "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler[]>;
    setupHandlers(props: {
        handlers: Map<types.MessageType<types.Message>, types.Handler>;
        registrator?: Function | undefined;
        isBoundable?: boolean | undefined;
        handleableTypes?: types.MessageType<types.Message>[] | undefined;
    }): void;
    handles(): Map<types.MessageType<types.Command>, types.Handler>;
    subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
    overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
    hasHandler(messageType: types.MessageType<types.Message>): boolean;
    removeHandler(messageType: types.MessageType<types.Message>): void;
    getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
    setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
    getHandleableTypes(): types.MessageType<types.Message>[];
    ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    getHandledTypes(): types.MessageType<types.Message>[];
    getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
    getHandledMessages(): types.MessageType<types.Message>[];
    getHandledCommands(): types.MessageType<types.Command>[];
    getHandledEvents(): types.MessageType<types.Event>[];
    getHandledTypesNames(): string[];
    "eveble:handleable-types": types.MessageType<types.Message>[];
}) & {
    prototype: {
        [x: string]: any;
        commandBus: types.CommandBus;
        initialize(): void;
        setupCommandHandlers(): void;
        registerCommandHandler(commandType: types.MessageType<types.Command>, handler: types.Handler, shouldOverride?: boolean): void;
        send(command: types.Command): Promise<any>;
        registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
        getHandler(messageType: types.MessageType<types.Message>): types.Handler | undefined;
        getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler;
        getTypeByHandler(handlerReference: types.Handler): any;
        handle(message: types.Message): Promise<any>;
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler>;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
} & {
    prototype: {
        [x: string]: any;
        initialize(): void;
        registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
        getHandler(messageType: types.MessageType<types.Message>): types.Handler | undefined;
        getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler;
        getTypeByHandler(handlerReference: types.Handler): any;
        handle(message: types.Message): Promise<any>;
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler>;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
} & {
    [x: string]: any;
    prototype: {
        [x: string]: any;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        registerHandler(_messageType: types.MessageType<types.Message>, _handler: types.Handler, _shouldOverride?: boolean): void;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
} & {
    prototype: {
        [x: string]: any;
        eventBus: types.EventBus;
        initialize(): void;
        setupEventHandlers(): void;
        registerEventHandler(eventType: types.MessageType<types.Event>, handler: types.Handler, shouldOverride?: boolean): void;
        subscribeTo(eventType: types.MessageType<types.Event>, handler: types.Handler, shouldOverride?: boolean | undefined): void;
        getSubscribedEvents(): types.MessageType<types.Event>[];
        on(event: types.Event): Promise<void>;
        publish(event: types.Event): Promise<void>;
        registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
        getHandler(messageType: types.MessageType<types.Message>): types.Handler[] | undefined;
        getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler[];
        getTypeByHandler(handlerReference: types.Handler): any;
        handle(message: types.Message, execution?: types.Execution): Promise<void>;
        handleSequential(message: types.Message): Promise<void>;
        handleConcurrent(message: types.Message): Promise<any>;
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler[]>;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
} & {
    prototype: {
        [x: string]: any;
        initialize(): void;
        registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
        getHandler(messageType: types.MessageType<types.Message>): types.Handler[] | undefined;
        getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler[];
        getTypeByHandler(handlerReference: types.Handler): any;
        handle(message: types.Message, execution?: types.Execution): Promise<void>;
        handleSequential(message: types.Message): Promise<void>;
        handleConcurrent(message: types.Message): Promise<any>;
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler[]>;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
};
export declare class Service extends Service_base {
    commandBus: types.CommandBus;
    eventBus: types.EventBus;
    initialize(): void;
}
export {};
