import { Entity } from './entity';
import { OneToOneHandlingMixin } from '../mixins/one-to-one-handling-mixin';
import { types } from '../types';
import { EVENTS_KEY, COMMANDS_KEY } from '../constants/literal-keys';
import { Guid } from './value-objects/guid';
import { History } from './history';
declare const EventSourceable_base: import("polytype").Polytype.ClusteredConstructor<[typeof Entity, typeof OneToOneHandlingMixin]>;
export declare class EventSourceable extends EventSourceable_base implements types.EventSourceable {
    id: string | Guid;
    version: number;
    state: types.State;
    status: types.Status;
    metadata?: Record<string, any>;
    schemaVersion?: number;
    [COMMANDS_KEY]: types.Command[];
    [EVENTS_KEY]: types.Event[];
    constructor(props: types.Props);
    initialize(): Promise<void>;
    protected processProps(props?: types.Props): types.Props;
    getVersion(): number;
    setVersion(version: number): void;
    getEvents(): types.Event[];
    getCommands(): types.Command[];
    handle(message: types.Command | types.Event): Promise<any>;
    schedule(command: types.Command, deliverAt: Date, assignmentId?: string | Guid): void;
    unschedule(assignmentId: string | Guid, commandType: types.MessageType<types.Command>): void;
    protected assign(...sources: Record<string, any>[]): this;
    record(event: types.Event): void;
    replay(event: types.Event): void;
    replayHistory(history: History): void;
    assignMetadata(metadata: Record<string, any>): void;
    protected updateToEventVersion(event: types.Event): void;
    protected validateEventApplicability(event: types.Event): boolean;
    eventProps(): {
        sourceId: Guid | string;
        timestamp: Date;
        metadata: Record<string, any>;
        version: number;
    };
    commandProps(): {
        timestamp: Date;
        metadata: Record<string, any>;
    };
    incrementVersion(): void;
    static resolveInitializingMessage(): types.MessageType<types.Command | types.Event> | undefined;
    static resolveRoutedCommands(): types.MessageType<types.Command>[];
    static resolveRoutedEvents(): types.MessageType<types.Event>[];
    static resolveRoutedMessages(): types.MessageType<types.Command | types.Event>[];
}
export {};
