import { Entity } from './entity';
import { types } from '../types';
import { EVENTS_KEY, COMMANDS_KEY } from '../constants/literal-keys';
import { Guid } from './value-objects/guid';
import { History } from './history';
declare const EventSourceable_base: (new (props: types.Props) => {
    [x: string]: any;
    initialize(): void;
    registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
    getHandler(messageType: types.MessageType<types.Message>): types.Handler | undefined;
    getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler;
    getTypeByHandler(handlerReference: types.Handler): any;
    handle(message: types.Message): Promise<any>;
    "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler>;
    setupHandlers(props: {
        handlers: Map<types.MessageType<types.Message>, types.Handler>;
        registrator?: Function | undefined;
        isBoundable?: boolean | undefined;
        handleableTypes?: types.MessageType<types.Message>[] | undefined;
    }): void;
    handles(): Map<types.MessageType<types.Command>, types.Handler>;
    subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
    overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
    hasHandler(messageType: types.MessageType<types.Message>): boolean;
    removeHandler(messageType: types.MessageType<types.Message>): void;
    getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
    setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
    getHandleableTypes(): types.MessageType<types.Message>[];
    ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    getHandledTypes(): types.MessageType<types.Message>[];
    getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
    getHandledMessages(): types.MessageType<types.Message>[];
    getHandledCommands(): types.MessageType<types.Command>[];
    getHandledEvents(): types.MessageType<types.Event>[];
    getHandledTypesNames(): string[];
    "eveble:handleable-types": types.MessageType<types.Message>[];
} & {
    [x: string]: any;
    setupHandlers(props: {
        handlers: Map<types.MessageType<types.Message>, types.Handler>;
        registrator?: Function | undefined;
        isBoundable?: boolean | undefined;
        handleableTypes?: types.MessageType<types.Message>[] | undefined;
    }): void;
    handles(): Map<types.MessageType<types.Command>, types.Handler>;
    subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
    registerHandler(_messageType: types.MessageType<types.Message>, _handler: types.Handler, _shouldOverride?: boolean): void;
    overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
    hasHandler(messageType: types.MessageType<types.Message>): boolean;
    removeHandler(messageType: types.MessageType<types.Message>): void;
    getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
    setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
    getHandleableTypes(): types.MessageType<types.Message>[];
    ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
    getHandledTypes(): types.MessageType<types.Message>[];
    getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
    getHandledMessages(): types.MessageType<types.Message>[];
    getHandledCommands(): types.MessageType<types.Command>[];
    getHandledEvents(): types.MessageType<types.Event>[];
    getHandledTypesNames(): string[];
    "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
    "eveble:handleable-types": types.MessageType<types.Message>[];
} & Entity) & {
    prototype: {
        [x: string]: any;
        initialize(): void;
        registerHandler(messageType: types.MessageType<types.Message>, handler: types.Handler, shouldOverride?: boolean): void;
        getHandler(messageType: types.MessageType<types.Message>): types.Handler | undefined;
        getHandlerOrThrow(messageType: types.MessageType<types.Message>): types.Handler;
        getTypeByHandler(handlerReference: types.Handler): any;
        handle(message: types.Message): Promise<any>;
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler>;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
} & {
    [x: string]: any;
    prototype: {
        [x: string]: any;
        setupHandlers(props: {
            handlers: Map<types.MessageType<types.Message>, types.Handler>;
            registrator?: Function | undefined;
            isBoundable?: boolean | undefined;
            handleableTypes?: types.MessageType<types.Message>[] | undefined;
        }): void;
        handles(): Map<types.MessageType<types.Command>, types.Handler>;
        subscribes(): Map<types.MessageType<types.Event>, types.Handler>;
        registerHandler(_messageType: types.MessageType<types.Message>, _handler: types.Handler, _shouldOverride?: boolean): void;
        overrideHandler(messageType: types.MessageType<types.Message>, handler: types.Handler): void;
        hasHandler(messageType: types.MessageType<types.Message>): boolean;
        removeHandler(messageType: types.MessageType<types.Message>): void;
        getHandlers(): Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        setHandleableTypes(handleableTypes: types.MessageType<types.Message> | types.MessageType<types.Message>[]): void;
        getHandleableTypes(): types.MessageType<types.Message>[];
        ensureHandleability(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        isHandleabe(messageType: types.MessageType<types.Message>, handleableTypes?: types.MessageType<types.Message> | types.MessageType<types.Message>[]): boolean;
        getHandledTypes(): types.MessageType<types.Message>[];
        getHandled(messageType: types.MessageType<types.Message>): types.MessageType<types.Message>[];
        getHandledMessages(): types.MessageType<types.Message>[];
        getHandledCommands(): types.MessageType<types.Command>[];
        getHandledEvents(): types.MessageType<types.Event>[];
        getHandledTypesNames(): string[];
        "eveble:handlers": Map<types.MessageType<types.Message>, types.Handler | types.Handler[]>;
        "eveble:handleable-types": types.MessageType<types.Message>[];
    };
} & {
    prototype: Entity;
    from: typeof import("..").Serializable.from;
    typeName: () => string;
    toString: (() => string) & (() => string) & (() => string);
    getTypeName: () => string;
    excludedPropTypes?: string[] | undefined;
    getPropTypes: () => types.Props;
    getPropertyInitializers: () => types.Props;
};
export declare class EventSourceable extends EventSourceable_base implements types.EventSourceable {
    id: string | Guid;
    version: number;
    state: types.State;
    status: types.Status;
    metadata?: Record<string, any>;
    schemaVersion?: number;
    [COMMANDS_KEY]: types.Command[];
    [EVENTS_KEY]: types.Event[];
    constructor(props: types.Props);
    initialize(): Promise<void>;
    protected construct(props?: types.Props): void;
    protected processProps(props?: types.Props): types.Props;
    getVersion(): number;
    setVersion(version: number): void;
    getEvents(): types.Event[];
    getCommands(): types.Command[];
    handle(message: types.Command | types.Event): Promise<any>;
    schedule(command: types.Command, deliverAt: Date, assignmentId?: string | Guid): void;
    unschedule(assignmentId: string | Guid, commandType: types.MessageType<types.Command>): void;
    protected assign(...sources: Record<string, any>[]): this;
    record(event: types.Event): void;
    replay(event: types.Event): void;
    replayHistory(history: History): void;
    assignMetadata(metadata: Record<string, any>): void;
    protected updateToEventVersion(event: types.Event): void;
    protected validateEventApplicability(event: types.Event): boolean;
    eventProps(): {
        sourceId: Guid | string;
        timestamp: Date;
        metadata: Record<string, any>;
        version: number;
    };
    commandProps(): {
        timestamp: Date;
        metadata: Record<string, any>;
    };
    incrementVersion(): void;
    static resolveInitializingMessage(): types.MessageType<types.Command | types.Event> | undefined;
    static resolveRoutedCommands(): types.MessageType<types.Command>[];
    static resolveRoutedEvents(): types.MessageType<types.Event>[];
    static resolveRoutedMessages(): types.MessageType<types.Command | types.Event>[];
}
export {};
